# Kafka Multi-Terminal Lab: Full System Documentation

This document provides a comprehensive overview of the Kafka environment configured across six terminals, demonstrating both **Load Balancing** (Queueing) and **Fan-out** (Publish/Subscribe) architectures.

---

## ðŸ—ï¸ System Architecture



| Terminal | Process Role | Topic | Group Name | Strategy |
| :--- | :--- | :--- | :--- | :--- |
| **Terminal 1** | Infrastructure | N/A | N/A | **Broker/Coordinator** |
| **Terminal 2** | Consumer Instance 1 | `queue-test` | `app1` | **Load Balancing** |
| **Terminal 3** | Consumer Instance 2 | `queue-test` | `app1` | **Load Balancing** |
| **Terminal 4** | Consumer Instance 3 | `topic-test` | `app2` | **Fan-out (Sub A)** |
| **Terminal 5** | Consumer Instance 4 | `topic-test` | `app3` | **Fan-out (Sub B)** |
| **Terminal 6** | Producer | `topic-test` | N/A | **Data Entry** |

---

## ðŸ’» Terminal-by-Terminal Commands

### Terminal 1: Infrastructure & Topics
This terminal hosts the server processes and the initial topic definitions.
```bash
# 1. Start Zookeeper (The Manager)
/app/confluent-7.9.1/bin/zookeeper-server-start /app/confluent-7.9.1/etc/kafka/zookeeper.properties >/dev/null&

# 2. Start Kafka Broker (The Storage Engine)
/app/confluent-7.9.1/bin/kafka-server-start /app/confluent-7.9.1/etc/kafka/server.properties >/dev/null&

# 3. Create Topics (2 Partitions each)
/app/confluent-7.9.1/bin/kafka-topics --bootstrap-server localhost:9092 --create --topic queue-test --partitions 2 --replication-factor 1
/app/confluent-7.9.1/bin/kafka-topics --bootstrap-server localhost:9092 --create --topic topic-test --partitions 2 --replication-factor 1
```

### Terminal 2: Consumer Group app1 (Instance 1)
Designed to handle half the load of the `queue-test` topic.

```bash
export TOPIC_NAME=queue-test
export CONSUMER_GROUP_NAME=app1
java -cp ".:/opt/kafka/libs/*" com.example.KafkaConsumerExample
```
### Terminal 3: Consumer Group app1 (Instance 2)
Designed to handle the other half of the load of the queue-test topic.
```bash
export TOPIC_NAME=queue-test
export CONSUMER_GROUP_NAME=app1
java -cp ".:/opt/kafka/libs/*" com.example.KafkaConsumerExample
```

### Terminal 4: Consumer Group app2
An independent subscriber listening to topic-test. It receives every message sent to this topic.

```
export TOPIC_NAME=topic-test
export CONSUMER_GROUP_NAME=app2
java -cp ".:/opt/kafka/libs/*" com.example.KafkaConsumerExample
```
### Terminal 5: Consumer Group app3
A second independent subscriber listening to topic-test. It also receives every message sent to this topic.

```
export TOPIC_NAME=topic-test
export CONSUMER_GROUP_NAME=app3
java -cp ".:/opt/kafka/libs/*" com.example.KafkaConsumerExample
```

### Terminal 6: Keyed Producer
This terminal is used to manually send messages into the system.

```
./kafka-console-producer --broker-list localhost:9092 --topic topic-test --property "parse.key=true" --property "key.separator=:"
# Input format: KEY:VALUE (e.g., user1:login_event)
```
### ðŸŽ“ Key Concepts Demonstrated
1. Load Balancing (T2 & T3)
When multiple consumers share the same CONSUMER_GROUP_NAME, Kafka treats them as a team. Since queue-test has 2 partitions, Kafka assigns Partition 0 to Terminal 2 and Partition 1 to Terminal 3.

2. Fan-out / Pub-Sub (T4 & T5)
Because Terminal 4 and Terminal 5 have different group names (app2 vs app3), they do not share the load. Instead, they each get a private copy of the data stream. This is ideal for microservices where multiple apps need the same data (e.g., an Analytics service and an Email service).

3. Keyed Message Routing
By using key:value in Terminal 6, Kafka hashes the key to decide which partition the message goes to. This ensures that all messages for the same key (like the same User ID) are processed in order by the same consumer.

